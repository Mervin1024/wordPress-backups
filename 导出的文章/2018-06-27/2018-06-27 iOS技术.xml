<?xml version="1.0" encoding="UTF-8" ?>
<!-- This is a WordPress eXtended RSS file generated by WordPress as an export of your site. -->
<!-- It contains information about your site's posts, pages, comments, categories, and other content. -->
<!-- You may use this file to transfer that content from one site to another. -->
<!-- This file is not intended to serve as a complete backup of your site. -->

<!-- To import this information into a WordPress site follow these steps: -->
<!-- 1. Log in to that site as an administrator. -->
<!-- 2. Go to Tools: Import in the WordPress admin panel. -->
<!-- 3. Install the "WordPress" importer from the list. -->
<!-- 4. Activate & Run Importer. -->
<!-- 5. Upload this file using the form provided on that page. -->
<!-- 6. You will first be asked to map the authors in this export file to users -->
<!--    on the site. For each author, you may choose to map to an -->
<!--    existing user on the site or to create a new user. -->
<!-- 7. WordPress will then import each of the posts, pages, comments, categories, etc. -->
<!--    contained in this file into your site. -->

<!-- generator="WordPress/4.9.6" created="2018-06-27 09:48" -->
<rss version="2.0"
	xmlns:excerpt="http://wordpress.org/export/1.2/excerpt/"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:wp="http://wordpress.org/export/1.2/"
>

<channel>
	<title>Mervin1024</title>
	<link>https://mervin1024.com</link>
	<description>快乐的挖坑踩坑之路…</description>
	<pubDate>Wed, 27 Jun 2018 09:48:11 +0000</pubDate>
	<language>zh-CN</language>
	<wp:wxr_version>1.2</wp:wxr_version>
	<wp:base_site_url>https://mervin1024.com</wp:base_site_url>
	<wp:base_blog_url>https://mervin1024.com</wp:base_blog_url>

	<wp:author><wp:author_id>1</wp:author_id><wp:author_login><![CDATA[mervin1024]]></wp:author_login><wp:author_email><![CDATA[mervin1024@163.com]]></wp:author_email><wp:author_display_name><![CDATA[mervin1024]]></wp:author_display_name><wp:author_first_name><![CDATA[]]></wp:author_first_name><wp:author_last_name><![CDATA[]]></wp:author_last_name></wp:author>

	<wp:category>
		<wp:term_id>4</wp:term_id>
		<wp:category_nicename><![CDATA[ios-development-diary]]></wp:category_nicename>
		<wp:category_parent><![CDATA[]]></wp:category_parent>
		<wp:cat_name><![CDATA[iOS技术]]></wp:cat_name>
<wp:category_description><![CDATA[闲来所写下的一些开发记录，这里都是iOS相关的。]]></wp:category_description>
	</wp:category>

	<generator>https://wordpress.org/?v=4.9.6</generator>

<image>
	<url>https://mervin1024.com/wp-content/uploads/2018/04/cropped-wallpaper-elf_83146ca0gw1f4o22z0nevj20m80m8gpi@3x-e1523326295928-32x32.jpg</url>
	<title>Mervin1024</title>
	<link>https://mervin1024.com</link>
	<width>32</width>
	<height>32</height>
</image> 

	<item>
		<title>iOS开发 - 动画实践系列</title>
		<link>https://mervin1024.com/technical-blogs/ios-development-diary/post-60</link>
		<pubDate>Tue, 10 Apr 2018 03:34:41 +0000</pubDate>
		<dc:creator><![CDATA[mervin1024]]></dc:creator>
		<guid isPermaLink="false">http://138.128.199.164/?p=60</guid>
		<description></description>
		<content:encoded><![CDATA[<h2>前言</h2>

打算开个新坑，只为记录自己在平时所写的一些动画效果。从简单的 View 动画到复杂的转场动画、加载动画都做一些尝试。一步一步来！

整体项目先丢这里 <a href="https://github.com/Mervin1024/LearnAnimation">github</a>。

<h2>目录及预览（待补充）</h2>

<h4>1.<a href="https://juejin.im/post/5aaccee16fb9a028c3689084">扩散波纹</a></h4>

<img src="https://user-gold-cdn.xitu.io/2018/3/12/1621964bdfd9d338?w=200&h=200&f=gif&s=127818" width="22%" height="22%">
<img src="https://user-gold-cdn.xitu.io/2018/3/12/1621964be3a78bba?w=204&h=204&f=gif&s=81903" width="20%" height="20%">

<h4>2.<a href="https://juejin.im/post/5a31d9696fb9a04500031005">复杂动画的实现</a></h4>

这个动画是参考的<a href="https://juejin.im/post/5a31d9696fb9a04500031005">@HenryCheng</a>的帖子，非常喜欢，作为记录放在这里吧。

<img src="https://user-gold-cdn.xitu.io/2018/3/17/1623365668edb787?w=314&h=524&f=gif&s=128270" width="20%" height="20%">

<h2>附言</h2>

将动画记录于此也是为了能够和大家交流，互相学习。个人感觉动画效果的设计需要很多灵感以及借鉴。而从视觉效果到真正的代码，实现方式多种多样，我也会尽量写下我所知道的、所踩过的坑，希望大家能互相交流意见。

欢迎联系我 <a href="mailto:mervin1024@163.com">Mervin1024@163.com</a>。]]></content:encoded>
		<excerpt:encoded><![CDATA[打算开个新坑，只为记录自己在平时所写的一些动画效果。从简单的 View 动画到复杂的转场动画、加载动画都做一些尝试。]]></excerpt:encoded>
		<wp:post_id>60</wp:post_id>
		<wp:post_date><![CDATA[2018-04-10 11:34:41]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-04-10 03:34:41]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[ios%e5%bc%80%e5%8f%91-%e5%8a%a8%e7%94%bb%e5%ae%9e%e8%b7%b5%e7%b3%bb%e5%88%97]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="ios"><![CDATA[iOS]]></category>
		<category domain="category" nicename="ios-development-diary"><![CDATA[iOS技术]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[46]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_thumbnail_id]]></wp:meta_key>
			<wp:meta_value><![CDATA[76]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_rp_related_posts_query_result_cache_expiration]]></wp:meta_key>
			<wp:meta_value><![CDATA[1528854501]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_rp_related_posts_query_result_cache_5]]></wp:meta_key>
			<wp:meta_value><![CDATA[a:7:{i:0;O:8:"stdClass":2:{s:7:"post_id";s:2:"63";s:5:"score";s:18:"10.762650419417287";}i:1;O:8:"stdClass":2:{s:7:"post_id";s:3:"182";s:5:"score";s:17:"8.565425841581067";}i:2;O:8:"stdClass":2:{s:7:"post_id";s:3:"172";s:5:"score";s:17:"8.565425841581067";}i:3;O:8:"stdClass":2:{s:7:"post_id";s:3:"120";s:5:"score";s:17:"7.990061697177506";}i:4;O:8:"stdClass":2:{s:7:"post_id";s:3:"147";s:5:"score";s:18:"0.5753641444035617";}i:5;O:8:"stdClass":2:{s:7:"post_id";s:3:"116";s:5:"score";s:18:"0.5753641444035617";}i:6;O:8:"stdClass":2:{s:7:"post_id";s:2:"68";s:5:"score";s:18:"0.5753641444035617";}}]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>iOS动画-扩散波纹效果</title>
		<link>https://mervin1024.com/technical-blogs/ios-development-diary/post-63</link>
		<pubDate>Tue, 10 Apr 2018 04:34:18 +0000</pubDate>
		<dc:creator><![CDATA[mervin1024]]></dc:creator>
		<guid isPermaLink="false">http://138.128.199.164/?p=63</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>最终效果</h3>

<img src="https://user-gold-cdn.xitu.io/2018/3/12/1621964bdfd9d338?w=200&h=200&f=gif&s=127818" width="22%" height="22%">
<img src="https://user-gold-cdn.xitu.io/2018/3/12/1621964be3a78bba?w=204&h=204&f=gif&s=81903" width="20%" height="20%">

<h3>实现思路</h3>

动画的表现形式是颜色以及大小的变化，整体效果可以看做多个单独的波纹效果的叠加。因此我们可以创建多个<code>CALayer</code>，分别赋予<code>CABasicAnimation</code>动画，组成最终的动画效果。

因此我们先从单个波纹扩散效果来尝试，然后根据时间差将效果叠加起来。

<h3>代码</h3>

<h4>1.新建动画 View <code>RippleAnimationView</code>，动画效果在<code>animationLayer</code>上实现。</h4>

新建<code>RippleAnimationView</code>类，继承自<code>UIView</code>，设置扩散倍数，然后重写<code>- (void)drawRect:(CGRect)rect</code>方法，在方法内部新建承载动画的<code>animationLayer</code>。

<pre><code>#import &lt;UIKit/UIKit.h&gt;

@interface RippleAnimationView : UIView

/**
 设置扩散倍数。默认1.423倍
 */
@property (nonatomic, assign) CGFloat multiple;

- (instancetype)initWithFrame:(CGRect)frame;

@end




@implementation RippleAnimationView

- (instancetype)initWithFrame:(CGRect)frame {
    self = [super initWithFrame:frame];

    if (self) {
        self.backgroundColor = [UIColor clearColor];
       _multiple = 1.423;
    }

    return self;
}

- (void)drawRect:(CGRect)rect {

    CALayer *animationLayer = [CALayer layer];

    // 加入动画

    [self.layer addSublayer:animationLayer];
}


</code></pre>

<h4>2.创建单个扩散的动画承载<code>CALayer</code>，实现扩散效果。</h4>

<ol>
<li>首先实现缩放动画</li>
</ol>

<pre><code>- (CABasicAnimation *)scaleAnimation {
    CABasicAnimation *scaleAnimation = [CABasicAnimation animationWithKeyPath:@"transform.scale"];

    scaleAnimation.fromValue = @1;
    scaleAnimation.toValue = @(_multiple);
    scaleAnimation.beginTime = CACurrentMediaTime();
    scaleAnimation.duration = 3;
    scaleAnimation.repeatCount = HUGE;// 重复次数设置为无限

    return scaleAnimation;
}

</code></pre>

<ol>
<li>新建<code>CALayer</code>，并在<code>layer</code>上加载动画。然后将这个<code>Layer</code>放在<code>animationLayer</code>上。</li>
</ol>

<pre><code>- (void)drawRect:(CGRect)rect {

    CALayer *animationLayer = [CALayer layer];

    // 新建缩放动画
    CABasicAnimation *animation = [self scaleAnimation];

    // 新建一个动画 Layer，将动画添加上去
    CALayer *pulsingLayer = [self pulsingLayer:rect animation:animation];

    //将动画 Layer 添加到 animationLayer
    [animationLayer addSublayer:pulsingLayer];

    [self.layer addSublayer:animationLayer];
}

- (CALayer *)pulsingLayer:(CGRect)rect animation:(CABasicAnimation *)animation {
    CALayer *pulsingLayer = [CALayer layer];

    pulsingLayer.borderWidth = 0.5;
    pulsingLayer.borderColor = [UIColor blackColor].CGColor;
    pulsingLayer.frame = CGRectMake(0, 0, rect.size.width, rect.size.height);
    pulsingLayer.cornerRadius = rect.size.height / 2;

    [pulsingLayer addAnimation:animation forKey:@"plulsing"];

    return pulsingLayer;
}

</code></pre>

可以看看现在的效果是这样的

<img src="https://user-gold-cdn.xitu.io/2018/3/17/16233314e1cad363?w=204&h=204&f=gif&s=51461" width="20%" height="20%">

<h4>3. 加入背景色以及边框色的渐变效果，将单一的缩放动画合并为动画组<code>CAAnimationGroup</code>。</h4>

（ps: 除了改变背景色，还要设置并改变边框色的更主要原因是去除锯齿）

<pre><code>// 设置一个初始化颜色的宏
#define ColorWithAlpha(r,g,b,a) [UIColor colorWithRed:r/255.0 green:g/255.0 blue:b/255.0 alpha:a]

- (void)drawRect:(CGRect)rect {

    CALayer *animationLayer = [CALayer layer];

    // 这里同时创建[缩放动画、背景色渐变、边框色渐变]三个简单动画
    NSArray *animationArray = [self animationArray];

    // 将三个动画合并为一个动画组
    CAAnimationGroup *animationGroup = [self animationGroupAnimations:animationArray];

    //修改方法，将原先添加的动画由“简单动画”改为“动画组”
    CALayer *pulsingLayer = [self pulsingLayer:rect animation:animationGroup];

    //将动画 Layer 添加到 animationLayer
    [animationLayer addSublayer:pulsingLayer];

    [self.layer addSublayer:animationLayer];
}

- (NSArray *)animationArray {
    NSArray *animationArray = nil;

    CABasicAnimation *scaleAnimation = [self scaleAnimation];
    CAKeyframeAnimation *borderColorAnimation = [self borderColorAnimation];
    CAKeyframeAnimation *backgroundColorAnimation = [self backgroundColorAnimation];
    animationArray = @[scaleAnimation, backgroundColorAnimation, borderColorAnimation];

    return animationArray;
}


- (CAAnimationGroup *)animationGroupAnimations:(NSArray *)array {
    CAAnimationGroup *animationGroup = [CAAnimationGroup animation];

    animationGroup.beginTime = CACurrentMediaTime();
    animationGroup.duration = 3;
    animationGroup.repeatCount = HUGE;
    animationGroup.animations = array;
    animationGroup.removedOnCompletion = NO;
    return animationGroup;
}


- (CABasicAnimation *)scaleAnimation {
    CABasicAnimation *scaleAnimation = [CABasicAnimation animationWithKeyPath:@"transform.scale"];

    scaleAnimation.fromValue = @1;
    scaleAnimation.toValue = @(_multiple);
    return scaleAnimation;
}


// 使用关键帧动画，使得颜色动画不要那么的线性变化
- (CAKeyframeAnimation *)backgroundColorAnimation {
    CAKeyframeAnimation *backgroundColorAnimation = [CAKeyframeAnimation animation];

    backgroundColorAnimation.keyPath = @"backgroundColor";
    backgroundColorAnimation.values = @[(__bridge id)ColorWithAlpha(255, 216, 87, 0.5).CGColor,
                                        (__bridge id)ColorWithAlpha(255, 231, 152, 0.5).CGColor,
                                        (__bridge id)ColorWithAlpha(255, 241, 197, 0.5).CGColor,
                                        (__bridge id)ColorWithAlpha(255, 241, 197, 0).CGColor];
    backgroundColorAnimation.keyTimes = @[@0.3,@0.6,@0.9,@1];
    return backgroundColorAnimation;
}

- (CAKeyframeAnimation *)borderColorAnimation {
    CAKeyframeAnimation *borderColorAnimation = [CAKeyframeAnimation animation];

    borderColorAnimation.keyPath = @"borderColor";
    borderColorAnimation.values = @[(__bridge id)ColorWithAlpha(255, 216, 87, 0.5).CGColor,
                                    (__bridge id)ColorWithAlpha(255, 231, 152, 0.5).CGColor,
                                    (__bridge id)ColorWithAlpha(255, 241, 197, 0.5).CGColor,
                                    (__bridge id)ColorWithAlpha(255, 241, 197, 0).CGColor];
    borderColorAnimation.keyTimes = @[@0.3,@0.6,@0.9,@1];
    return borderColorAnimation;
}

- (CALayer *)pulsingLayer:(CGRect)rect animation:(CAAnimationGroup *)animationGroup {
    CALayer *pulsingLayer = [CALayer layer];

    pulsingLayer.borderWidth = 0.5;
    pulsingLayer.borderColor = ColorWithAlpha(255, 216, 87, 0.5).CGColor;
    pulsingLayer.frame = CGRectMake(0, 0, rect.size.width, rect.size.height);
    pulsingLayer.cornerRadius = rect.size.height / 2;

    [pulsingLayer addAnimation:animationGroup forKey:@"plulsing"];

    return pulsingLayer;
}
</code></pre>

现在就有种渐变的感觉了

<img src="https://user-gold-cdn.xitu.io/2018/3/17/1623343ae3df6b9c?w=204&h=204&f=gif&s=65456" width="20%" height="20%">

<h4>4. 同时创建三个扩散动画的<code>CALyer</code>，将开始动画的时间错开，同时添加到<code>animationLayer</code>上。</h4>

<pre><code>// 设置静态常量 pulsingCount ，表示 Layer 的数量
static NSInteger const pulsingCount = 3;

// 设置静态常量 animationDuration ，表示动画时间
static double const animationDuration = 3;


- (void)drawRect:(CGRect)rect {

    CALayer *animationLayer = [CALayer layer];

    // 利用 for 循环创建三个动画 Layer
    for (int i = 0; i &lt; pulsingCount; i++) {
        NSArray *animationArray = [self animationArray];

        // 通过传入参数 i 计算，错开动画时间
        CAAnimationGroup *animationGroup = [self animationGroupAnimations:animationArray index:i];
        CALayer *pulsingLayer = [self pulsingLayer:rect animation:animationGroup];
        [animationLayer addSublayer:pulsingLayer];
    }

    [self.layer addSublayer:animationLayer];
}

... ...

- (CAAnimationGroup *)animationGroupAnimations:(NSArray *)array index:(int)index {
    CAAnimationGroup *animationGroup = [CAAnimationGroup animation];

    animationGroup.beginTime = CACurrentMediaTime() + (double)(index * animationDuration) / (double)pulsingCount;
    animationGroup.duration = animationDuration;
    animationGroup.repeatCount = HUGE;
    animationGroup.animations = array;
    animationGroup.removedOnCompletion = NO;
    return animationGroup;
}

... ...

</code></pre>

然后效果有点……一言难尽……

<img src="https://user-gold-cdn.xitu.io/2018/3/17/1623352451d82fdb?w=204&h=204&f=gif&s=41335" width="30%" height="30%">

真是很有纪律性的变化啊~~好吧，只需要加入动画曲线就好了

<h4>5. 最后加入动画速度曲线</h4>

<pre><code><br />... ...

- (CAAnimationGroup *)animationGroupAnimations:(NSArray *)array index:(int)index {
    CAAnimationGroup *animationGroup = [CAAnimationGroup animation];

    animationGroup.beginTime = CACurrentMediaTime() + (double)(index * animationDuration) / (double)pulsingCount;
    animationGroup.duration = animationDuration;
    animationGroup.repeatCount = HUGE;
    animationGroup.animations = array;
    animationGroup.removedOnCompletion = NO;

    // 添加动画曲线。关于其他的动画曲线，也可以自行尝试
    animationGroup.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionDefault];

    return animationGroup;
}

... ...

</code></pre>

如果需要点扩散，那就设置 frame 极小，同时扩散倍数增大即可。

将动画<code>View</code>垫在另一个圆形<code>View</code>之下即可实现最上方的效果。关闭背景色，重调边框色和边框宽度即可实现第二种效果。

<h3>最后</h3>

demo及代码 <a href="https://github.com/Mervin1024/LearnAnimation/tree/master/001-%E7%AE%80%E5%8D%95%E7%9A%84%E6%89%A9%E6%95%A3%E6%B3%A2%E7%BA%B9">在这里</a>。

个人的动画汇总帖在这里 <a href="https://juejin.im/post/5aa622e06fb9a028d3750c55">动画实践系列</a>。

欢迎交流意见 <a href="mailto:mervin1024@163.com">mervin1024@163.com</a>.]]></content:encoded>
		<excerpt:encoded><![CDATA[用CALayer的核心动画实现。]]></excerpt:encoded>
		<wp:post_id>63</wp:post_id>
		<wp:post_date><![CDATA[2018-04-10 12:34:18]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-04-10 04:34:18]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[ios%e5%8a%a8%e7%94%bb-%e6%89%a9%e6%95%a3%e6%b3%a2%e7%ba%b9%e6%95%88%e6%9e%9c]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="ios"><![CDATA[iOS]]></category>
		<category domain="category" nicename="ios-development-diary"><![CDATA[iOS技术]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[55]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_thumbnail_id]]></wp:meta_key>
			<wp:meta_value><![CDATA[65]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_rp_related_posts_query_result_cache_expiration]]></wp:meta_key>
			<wp:meta_value><![CDATA[1531974226]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_rp_related_posts_query_result_cache_5]]></wp:meta_key>
			<wp:meta_value><![CDATA[a:4:{i:0;O:8:"stdClass":2:{s:7:"post_id";s:3:"120";s:5:"score";s:17:"12.72430892494074";}i:1;O:8:"stdClass":2:{s:7:"post_id";s:2:"60";s:5:"score";s:18:"10.762650419417287";}i:2;O:8:"stdClass":2:{s:7:"post_id";s:3:"182";s:5:"score";s:17:"9.951720202700958";}i:3;O:8:"stdClass":2:{s:7:"post_id";s:3:"172";s:5:"score";s:17:"7.990061697177506";}}]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>iOS 全局修改UINavigationBar的返回按钮（适配 iOS 11）</title>
		<link>https://mervin1024.com/technical-blogs/ios-development-diary/post-120</link>
		<pubDate>Tue, 10 Apr 2018 09:06:47 +0000</pubDate>
		<dc:creator><![CDATA[mervin1024]]></dc:creator>
		<guid isPermaLink="false">http://138.128.199.164/?p=120</guid>
		<description></description>
		<content:encoded><![CDATA[<h2>前言</h2>

关于实现 App 全局统一样式的返回按钮，之前我们通过修改 <code>[[UIBarButtonItem appearance] setBackButtonTitlePositionAdjustment:]</code> 来改变返回按钮中文字的偏移量，来实现隐藏文字的效果。但是改完后不是很满意，给大家两张图感受一下

<img src="https://user-gold-cdn.xitu.io/2018/1/11/160e35967abfe75b?w=320&h=570&f=gif&s=1379091" width="20%" height="20%"> ←iOS10 <img src="https://user-gold-cdn.xitu.io/2018/1/11/160e3696b6fa2cf8?w=320&h=567&f=gif&s=1317767" width="20%" height="20%"> ←iOS11


很明显，iOS 11以下，即使隐藏了文字，但是如果原本文字过长依旧会出现标题被挤到右侧的情况，而iOS 11，文字会从偏移后的位置出现或消失，正常动画时间下会有种很突兀的感觉。


正好在这时，产品在新项目中提了个要求，返回按钮默认文字为“返回”，而不再是隐藏。那么如果我们能够实现修改默认返回按钮文字，只要设置文字为@" "也能达到隐藏的目的，一举两得！那么就来试试能不能修改默认值吧。

<h2>思路</h2>

<hr />

首先来看看<code>UIBarButtonItem</code>的相关Api，有没有能修改默认文字的方法。嗯……没找到………… 再找找<code>UINavigationBar</code>的相关Api，嗯……还是没找到………… 再看看<code>UINavigationItem</code>呢，嗯……还是找不到……~~接下来只能找产品改掉这个无理需求了~~


好吧，既然我们没法直接用苹果的Api搞定，那就自己来实现吧。很显然，无法调用外部Api就需要我们重写一些方法了，分类+runtime黑魔法是个很不错的方式。（什么？你说用继承？继承当然也可以实现，但是这种一点都不高大上，还要重新调整之前项目中旧代码的方式很明显第一时间就被我摒弃了。）所以接下来我们需要寻找关键的方法，然后通过重写来实现效果。



**写之前我们先来回忆一下<code>UINavigationBar</code>中的<code>UINavigationItem</code>和<code>UIBarButtonItem</code>:

**

<code>UINavigationBar</code>中的返回按钮以及标题、右侧按钮等控件都是由<code>UINavigationItem</code>属性来决定的，因此如果要修改这些内容，我们需要修改对应的<code>UINavigationItem</code>。

在一个<code>UINavigationController</code>中的视图控制器做切换的时候，<code>UINavigationBar</code>是顶部导航栏视图，它始终是唯一的。大家都知道<code>UINavigationController</code>通过栈的方式来管理视图控制器的，同样<code>UINavigationBar</code>也是通过栈的方式来管理不同的<code>UINavigationItem</code>。


<code>UINavigationItem</code>中的左侧按钮有两种：<code>backBarButtonItem</code>和<code>leftBarButtonItem</code>,虽然都能改变左侧按钮但是区别较大。


1. <code>backBarButtonItem</code>属性决定的是下一个视图返回当前视图的按钮，即设置A视图的<code>UINavigationItem.backBarButtonItem</code>，需要进入下一个B视图时，显示在左侧，不需要实现相应的点击事件；
2. <code>leftBarButtonItem</code>属性可以直接更改当前视图导航栏的左侧按钮，替代掉前一个视图的<code>backBarButtonItem</code>，需要自己实现点击事件，同时会关闭侧滑手势。



既然我们要修改默认返回按钮，那么直接修改<code>backBarButtonItem</code>就可以了。

<blockquote>
  这里请注意，我们修改的是‘默认’值，也就是缺省值。如果代码中单独设置了<code>backBarButtonItem</code>，我们不能去改变这个值。
</blockquote>

<h2>代码</h2>

<hr />

说了这么多，直接来看实现：


1. 新建<code>UINavigationItem</code>的分类

<pre><code>#import &lt;UIKit/UIKit.h&gt;

@interface UINavigationItem (BackItem)
@end
</code></pre>

<ol>
<li>导入runtime头文件，重写<code>backBarButtonItem</code>的getter方法</li>
</ol>

<pre><code>#import "UINavigationItem+BackItem.h"
#import &lt;objc/runtime.h&gt;

@implementation UINavigationItem (BackItem)

+(void)load{
    static dispatch_once_t onceToken;
    dispatch_once(&amp;onceToken, ^{

        Method originalMethodImp = class_getInstanceMethod(self, @selector(backBarButtonItem));
        Method destMethodImp = class_getInstanceMethod(self, @selector(myCustomBackButton_backBarbuttonItem));
        method_exchangeImplementations(originalMethodImp, destMethodImp);

    });
}

static char kCustomBackButtonKey;

-(UIBarButtonItem *)myCustomBackButton_backBarbuttonItem{
    //先get原本的backBarButtonItem，存在就直接返回，没有的话再返回默认按钮
    UIBarButtonItem *item = [self myCustomBackButton_backBarbuttonItem];
    if (item) {
        return item;
    }
    item = objc_getAssociatedObject(self, &amp;kCustomBackButtonKey);
    if (!item) {
        item = [[UIBarButtonItem alloc] initWithTitle:@"返回" style:UIBarButtonItemStylePlain target:nil action:NULL];
        objc_setAssociatedObject(self, &amp;kCustomBackButtonKey, item, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
    }
    return item;
}

- (void)dealloc
{
    objc_removeAssociatedObjects(self);
}

</code></pre>

这样的话，只要<code>backBarbuttonItem</code>属性通过 getter 请求获取，不会返回nil，那么系统就不会自动将上一个页面的title变为当前页面的返回按钮，我们就能实现默认返回按钮，那就来跑起来试试。

<img src="https://user-gold-cdn.xitu.io/2018/1/11/160e47f4f1261b91?w=320&h=568&f=gif&s=1249500" width="40%" height="40%">

好的，看起来是完美解决了，但是！！！！


这只是 iOS 10 下的运行结果，我们应该知道苹果在 iOS 11 对<code>UINavigationBar</code>进行了重构，视图层级等和以前的系统下已经不一样了，我们再在 iOS 11 下测验一下。

<img src="https://user-gold-cdn.xitu.io/2018/1/11/160e4868c0f0cb1d?w=320&h=566&f=gif&s=1316225" width="40%" height="40%">

是的，它在 iOS 11 下没有作用……如果你在<code>-(UIBarButtonItem *)myCustomBackButton_backBarbuttonItem</code>方法中加<code>NSLog</code>，你会发现<code>backBarbuttonItem</code>的getter方法不会被调用了，也就是说苹果已经不靠 getter 的方式来创建返回按钮了。（情绪渐渐失控.jpg）

<h2>适配 iOS 11</h2>

<hr />

好吧，有困难就要克服困难，分析下成功和失效原因就是了。我们通过修改<code>backBarbuttonItem</code>的getter方法，使得这个属性不会为空，只要苹果去取这个属性来配置<code>UINavigationBar</code>的返回按钮，必定会跳进我们给它下的套，拿到我们想让它拿到的值。事实也证明在 iOS 11 以下是没有问题的。

可是 iOS 11 之后苹果绕过了 getter ，也就是说苹果不再调用 getter 来获取返回按钮，那么它在什么时候设置的呢？



我们可以尝试无论怎么点击，getter方法都不会被调用，但是如果我们手动设置 A视图 的<code>backBarbuttonItem</code>，会发现，这样做是有效果的。我们可以由此推测，苹果在这个 setter 方法里就已经做了一些事情，来完成返回按钮的设置，这样就能解释为什么在后续的过程中不再需要<code>backBarbuttonItem</code>的 getter 方法。看来我们需要就这个 setter 方法做文章了。



那我们可以直接像重写<code>backBarbuttonItem</code>的 getter 方法那样重写 setter 方法吗？来，试一试。

<ol>
<li>新增加一个方法替换</li>
<li>将全局返回按钮的构造方法提出来单写一个方法</li>
<li>判断 setter 的时候参数为nil则赋值为默认按钮</li>
</ol>

<pre><code>#import "UINavigationItem+BackItem.h"
#import &lt;objc/runtime.h&gt;

@implementation UINavigationItem (BackItem)

+(void)load{
    static dispatch_once_t onceToken;
    dispatch_once(&amp;onceToken, ^{

        Method originalMethodImp = class_getInstanceMethod(self, @selector(backBarButtonItem));
        Method destMethodImp = class_getInstanceMethod(self, @selector(myCustomBackButton_backBarbuttonItem));
        method_exchangeImplementations(originalMethodImp, destMethodImp);

        Method setterOriginalMethodImp = class_getInstanceMethod(self, @selector(setBackBarButtonItem:));
        Method setterDestMethodImp = class_getInstanceMethod(self, @selector(myCustomBackButton_backBarbuttonItem));
        method_exchangeImplementations(setterOriginalMethodImp, setterDestMethodImp);


    });
}

static char kCustomBackButtonKey;

-(UIBarButtonItem *)myCustomBackButton_backBarbuttonItem{
    //先get原本的backBarButtonItem，存在就直接返回，没有的话再返回默认按钮
    UIBarButtonItem *item = [self myCustomBackButton_backBarbuttonItem];
    if (item) {
        return item;
    }
    item = objc_getAssociatedObject(self, &amp;kCustomBackButtonKey);
    if (!item) {
        item = [[self class] customGlobalBackBarButtonItem];
        objc_setAssociatedObject(self, &amp;kCustomBackButtonKey, item, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
    }
    return item;
}

- (void)myCustomBackButton_setBackBarButtonItem:(UIBarButtonItem *)backBarButtonItem {
    if (backBarButtonItem == nil) {
        UIBarButtonItem *item = objc_getAssociatedObject(self, &amp;kCustomBackButtonKey);
        if (!item) {
            item = [[self class] customGlobalBackBarButtonItem];
            objc_setAssociatedObject(self, &amp;kCustomBackButtonKey, item, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
        }
        backBarButtonItem = item;
    }
    [self myCustomBackButton_setBackBarButtonItem:backBarButtonItem];
}

+ (UIBarButtonItem *)customGlobalBackBarButtonItem {
    UIBarButtonItem *item = [[UIBarButtonItem alloc] initWithTitle:@"返回" style:UIBarButtonItemStylePlain target:nil action:NULL];
    return item;
}

- (void)dealloc
{
    objc_removeAssociatedObjects(self);
}

@end
</code></pre>

完成了！！好的，跑起来看看！！！效果如下图：

（鉴于此处的图和上一张图过于雷同，就不贴出来了，忘记的同学向上滑）

好吧，看到上一句话已经懂了，没有效果。为什么呢？<strong>因为 setter 方法没有被调用！</strong> 也就是说，苹果并没有去主动调用 setter 方法，我们换了也没用。所以只能由我们来找一个合适的时机去调用这个 setter 方法了。

<blockquote>
  记得回头删除掉刚才置换 setter 方法的无效代码
</blockquote>

<h2>寻找合适调用时机</h2>

<hr />

这里需要回顾之前关于“如何通过设置<code>backBarbuttonItem</code>来改变返回按钮”的部分了，我们设置了 A视图 的<code>NavigationItem.backBarbuttonItem</code>属性，那么它就会在下一个页面<code>push</code>进来的时候生效。也就是说这个属性只需要在要<code>push</code>进来新的控制器的时候再赋值给当前控制器对应的<code>NavigationItem</code>就可以了。所以我们需要找到并重写一个方法，这个方法需要满足~~两~~三点：


1. 在<code>push</code>新控制器的时候调用；
2. 由系统主动调用，否则无法触发我们置换过后的方法；
2. 方法中我们可以获得当前控制器的<code>NavigationItem</code>。

然后我们找找有没有相关的 Api。


首先<code>NavigationItem</code>是没有这样的方法的，因为它无法知道<code>UINavigationController</code>会不会<code>push</code>新的控制器。所以只能去其他类里面找。


接下来，我们可以在<code>UINavigationBar.h</code>中看到这样一个方法

<blockquote>
  <code>- (void)pushNavigationItem:(UINavigationItem *)item
  animated:(BOOL)animated;</code>
</blockquote>

看起来类似于<code>UINavigationController</code>的<code>push</code>方法，<code>UINavigationBar</code>也会<code>push</code>一个新的<code>NavigationItem</code>。那么我们就来试试这个方法：
1. 新建<code>UINavigationBar</code>的分类

<pre><code>#import &lt;UIKit/UIKit.h&gt;

@interface UINavigationBar (BackItem_iOS11)

@end
</code></pre>

<ol>
<li>导入runtime，重写<code>- (void)pushNavigationItem:(UINavigationItem *)item
animated:(BOOL)animated</code>这个方法。</li>
</ol>

<pre><code>#import "UINavigationBar+BackItem_iOS11.h"
#import &lt;objc/runtime.h&gt;

@implementation UINavigationBar (BackItem_iOS11)

+ (void)load {
    static dispatch_once_t onceToken;
    dispatch_once(&amp;onceToken, ^{

        Method originalMethodImp = class_getInstanceMethod(self, @selector(pushNavigationItem:animated:));
        Method destMethodImp = class_getInstanceMethod(self, @selector(iOS11CustomPushNavigationItem:animated:));
        method_exchangeImplementations(originalMethodImp, destMethodImp);

    });
}

- (void)iOS11CustomPushNavigationItem:(UINavigationItem *)item animated:(BOOL)animated {
    NSLog(@"%@------%@-------%@",item,self.topItem,self.backItem);

    [self iOS11CustomPushNavigationItem:item animated:animated];
}

@end

</code></pre>

这里增加打印，顺便看看方法中能拿到的三个<code>UINavigationItem</code>值是否包含我们需要的那个。
接下来点击next按钮看看：

<blockquote>
  &lt;<UINavigationItem: 0x7f8291c0c950>: title:'测试 BBBBBBBBB'>------&lt;<UINavigationItem: 0x7f8291c093f0>: title:'测试 AAAAAAAA'>-------(null)
</blockquote>

可以看到，打印成功的出来了，同时参数<code>item</code>就是即将<code>push</code>进来新的视图控制器所对应的<code>UINavigationItem</code>，而<code>UINavigationBar</code>的<code>topItem</code>就是我们需要的当前视图控制器的<code>UINavigationItem</code>。那么来动手改变这个<code>item</code>试试。不过在这之前，我们需要能够拿到我们写在<code>UINavigationItem+BackItem</code>类中的默认返回按钮构造方法，保证两个类从同一个方法中构造<code>backBarButtonItem</code>。很简单，将<code>+ (UIBarButtonItem *)customGlobalBackBarButtonItem</code>在<code>UINavigationItem+BackItem.h</code>中声明一下就好了。



直接来看代码吧：

<pre><code>#import "UINavigationBar+BackItem_iOS11.h"
#import "UINavigationItem+BackItem.h"
#import &lt;objc/runtime.h&gt;

@implementation UINavigationBar (BackItem_iOS11)

+ (void)load {
    static dispatch_once_t onceToken;
    dispatch_once(&amp;onceToken, ^{
        if (@available(iOS 11, *)) {    // iOS 11 以下无效
            Method originalMethodImp = class_getInstanceMethod(self, @selector(pushNavigationItem:animated:));
            Method destMethodImp = class_getInstanceMethod(self, @selector(iOS11CustomPushNavigationItem:animated:));
            method_exchangeImplementations(originalMethodImp, destMethodImp);
        }
    });
}

- (void)iOS11CustomPushNavigationItem:(UINavigationItem *)item animated:(BOOL)animated {
    if (!self.topItem.backBarButtonItem) {
        UIBarButtonItem *itemBarButton = [UINavigationItem customGlobalBackBarButtonItem];
        [self.topItem setBackBarButtonItem:itemBarButton];
    }

    [self iOS11CustomPushNavigationItem:item animated:animated];
}

@end
</code></pre>

为了缩短篇幅不再啰嗦，就直接说结果了。<code>UINavigationBar+BackItem_iOS11</code>可以在 iOS 11 完成默认返回按钮，但是之前也说了，iOS 11 和以下的版本对<code>UINavigationBar</code>的实现是不一样的，所以这个方法在 iOS 11 以下不生效。

<h2>完成</h2>

因为两个方案都不能兼容所有系统，但是效果互补，因此两个分类同时加入项目就能完成自定义默认返回按钮的效果了。


重新贴一下最终的<code>UINavigationItem+BackItem</code>代码

<pre><code>#import &lt;UIKit/UIKit.h&gt;

@interface UINavigationItem (BackItem)
+ (UIBarButtonItem *)customGlobalBackBarButtonItem;
@end




#import "UINavigationItem+BackItem.h"
#import &lt;objc/runtime.h&gt;

@implementation UINavigationItem (BackItem)

+(void)load{
    static dispatch_once_t onceToken;
    dispatch_once(&amp;onceToken, ^{
        if (@available(iOS 11.0, *)) {
            // iOS 11 无效
        } else {
            Method originalMethodImp = class_getInstanceMethod(self, @selector(backBarButtonItem));
            Method destMethodImp = class_getInstanceMethod(self, @selector(myCustomBackButton_backBarbuttonItem));
            method_exchangeImplementations(originalMethodImp, destMethodImp);
        }
    });
}

static char kCustomBackButtonKey;

-(UIBarButtonItem *)myCustomBackButton_backBarbuttonItem{
    UIBarButtonItem *item = [self myCustomBackButton_backBarbuttonItem];
    if (item) {
        return item;
    }
    item = objc_getAssociatedObject(self, &amp;kCustomBackButtonKey);
    if (!item) {
        item = [[self class] customGlobalBackBarButtonItem];
        objc_setAssociatedObject(self, &amp;kCustomBackButtonKey, item, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
    }
    return item;
}

+ (UIBarButtonItem *)customGlobalBackBarButtonItem {
    UIBarButtonItem *item = [[UIBarButtonItem alloc] initWithTitle:@"返回" style:UIBarButtonItemStylePlain target:nil action:NULL];
    return item;
}

- (void)dealloc
{
    objc_removeAssociatedObjects(self);
}

@end

</code></pre>

<h2>结束</h2>

最后的GitHub地址在这里 <a href="https://github.com/Mervin1024/NavigationBackItemDemo">NavigationBackItemDemo</a>。



<hr />

<strong>记得同时添加<code>UINavigationItem+BackItem</code>和<code>UINavigationBar+BackItem_iOS11</code>两个分类</strong>]]></content:encoded>
		<excerpt:encoded><![CDATA[实现 App 全局统一样式的返回按钮。（适配 iOS 11 ）]]></excerpt:encoded>
		<wp:post_id>120</wp:post_id>
		<wp:post_date><![CDATA[2018-04-10 17:06:47]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-04-10 09:06:47]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[ios-%e5%85%a8%e5%b1%80%e4%bf%ae%e6%94%b9uinavigationbar%e7%9a%84%e8%bf%94%e5%9b%9e%e6%8c%89%e9%92%ae%ef%bc%88%e9%80%82%e9%85%8d-ios-11%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="ios"><![CDATA[iOS]]></category>
		<category domain="category" nicename="ios-development-diary"><![CDATA[iOS技术]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_thumbnail_id]]></wp:meta_key>
			<wp:meta_value><![CDATA[121]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[92]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_rp_related_posts_query_result_cache_expiration]]></wp:meta_key>
			<wp:meta_value><![CDATA[1531279679]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_rp_related_posts_query_result_cache_6]]></wp:meta_key>
			<wp:meta_value><![CDATA[a:2:{i:0;O:8:"stdClass":2:{s:7:"post_id";s:2:"63";s:5:"score";s:17:"12.34919852471846";}i:1;O:8:"stdClass":2:{s:7:"post_id";s:2:"60";s:5:"score";s:17:"8.684035597221841";}}]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_rp_related_posts_query_result_cache_5]]></wp:meta_key>
			<wp:meta_value><![CDATA[a:4:{i:0;O:8:"stdClass":2:{s:7:"post_id";s:3:"182";s:5:"score";s:18:"14.685967430464192";}i:1;O:8:"stdClass":2:{s:7:"post_id";s:2:"63";s:5:"score";s:17:"12.72430892494074";}i:2;O:8:"stdClass":2:{s:7:"post_id";s:3:"172";s:5:"score";s:17:"9.951720202700958";}i:3;O:8:"stdClass":2:{s:7:"post_id";s:2:"60";s:5:"score";s:17:"7.990061697177506";}}]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>4</wp:comment_id>
			<wp:comment_author><![CDATA[iOS 全局修改系统导航栏返回按钮样式 – Mervin1024]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[]]></wp:comment_author_email>
			<wp:comment_author_url>https://mervin1024.com/technical-blogs/ios-development-diary/post-182</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[138.128.199.164]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-05-09 17:18:59]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-05-09 09:18:59]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[[&#8230;] 我之前有写过一个关于全局设置导航栏返回按钮的文章，在这里。通过类别的方式，直接导入文件即可生效。但是有几点不便之处：一是没有暴露接口去设置返回按钮的样式，默认样式直接写在类的方法实现中；二是没有使用 cocoapods 管理，不符合工具类组件化管理的原则。因此做了二次修改。 [&#8230;]]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[pingback]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_result]]></wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_history]]></wp:meta_key>
				<wp:meta_value><![CDATA[a:2:{s:4:"time";d:1525857539.5939729;s:5:"event";s:9:"check-ham";}]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_history]]></wp:meta_key>
				<wp:meta_value><![CDATA[a:3:{s:4:"time";d:1527587868.12888;s:5:"event";s:15:"status-approved";s:4:"user";s:10:"mervin1024";}]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_history]]></wp:meta_key>
				<wp:meta_value><![CDATA[a:3:{s:4:"time";d:1529463452.4429319;s:5:"event";s:17:"status-unapproved";s:4:"user";s:10:"mervin1024";}]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_history]]></wp:meta_key>
				<wp:meta_value><![CDATA[a:3:{s:4:"time";d:1529463455.5977471;s:5:"event";s:15:"status-approved";s:4:"user";s:10:"mervin1024";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
		<title>如何一行代码完成页面自定义跳转</title>
		<link>https://mervin1024.com/technical-blogs/ios-development-diary/post-172</link>
		<pubDate>Fri, 20 Apr 2018 14:47:06 +0000</pubDate>
		<dc:creator><![CDATA[mervin1024]]></dc:creator>
		<guid isPermaLink="false">http://mervin1024.com/?p=172</guid>
		<description></description>
		<content:encoded><![CDATA[<h2>前言</h2>

这篇博文主要是记录一些实现思路，顺便将平时实现转场动画时遇到的一些问题和细节整理下来，也方便巩固下知识。在这里作为示例的转场动画也是目前项目中有使用到的，如果后续还有新的转场方式也会放在这里。

<h2>使用</h2>

<img src="https://mervin1024.com/wp-content/uploads/2018/05/May-04-2018-15-18-07.gif" width="30%" height="30%">

<pre><code>- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath {
    MERSecondViewController *controller = [[MERSecondViewController alloc] init];
    CGFloat screenWidth = [UIScreen mainScreen].bounds.size.width;
    CGFloat screenHeight = [UIScreen mainScreen].bounds.size.height;
    [tableView deselectRowAtIndexPath:indexPath animated:YES];

    // Action Sheet
    if (indexPath.row == MERPresentationAnimationTypeActionSheet) {
        controller.mer_viewSize = CGSizeMake(screenWidth / 6.0 * 5, screenHeight / 5.0 * 2);
        [self presentActionSheetViewController:controller animated:YES completion:nil];


    // 侧边滑入
    } else if (indexPath.row == MERPresentationAnimationTypeSlider) {
        controller.mer_viewSize = CGSizeMake(screenWidth / 3.0 * 2, screenHeight);
        [self presentSliderViewController:controller direction:MERSlidePresentationDirectionLeft animated:YES completion:nil];

    // 淡入淡出
    } else if (indexPath.row == MERPresentationAnimationTypeFade) {
        [self presentFadePatternViewController:controller animated:YES completion:nil];

    // 点扩散
    } else if (indexPath.row == MERPresentationAnimationTypeDiffuse) {
        [self presentDiffuseViewController:controller startPoint:_clickView.lastClickPoint animated:YES completion:nil];

    }
}

</code></pre>

<a href="https://github.com/Mervin1024/MERPresentation">示例代码在这里</a>

<h2>转场的实现步骤</h2>

关于 iOS 转场动画的详细解读，可以参考这两篇文章：王巍写的 <a href="https://onevcat.com/2013/10/vc-transition-in-ios7/">ViewController切换</a> 和唐巧写的 <a href="http://blog.devtang.com/2016/03/13/iOS-transition-guide/">iOS 视图控制器转场详解</a> 。篇幅较长，写的非常详细。

<h4>1.实现转场代理</h4>

<ul>
<li><code>UIViewController</code> 的转场代理为 <code>transitioningDelegate</code> 属性，遵循 <code>&lt;UIViewControllerTransitioningDelegate&gt;</code> 协议;</li>
<li><code>UINavigationController</code> 的转场代理为 <code>delegate</code> 属性，遵循 <code>&lt;UINavigationControllerDelegate&gt;</code> 协议;</li>
<li><code>UITabBarController</code> 的转场代理为 <code>delegate</code> 属性，遵循 <code>&lt;UITabBarControllerDelegate&gt;</code> 协议;</li>
</ul>

因此我们只需要新建一个代理类，遵循并实现相应的代理，然后赋值给对应的代理属性即可。

<blockquote>
  其中 Present 转场需要给被 present 出来的 <code>UIViewController</code> 设置代理，实现 present 和 dismiss 的自定义动画。
  Push 转场则需要给导航控制器 <code>UINavigationController</code> 设置代理，需要注意设置代理后如果只为限定的 VC 采用自定义动画，需要在代理的实现方法中做区分才行。<br />
  Tabbar 转场同理。
</blockquote>

本篇主要以 Present 转场举例，下面是 <code>&lt;UIViewControllerTransitioningDelegate&gt;</code> 需要实现的方法

<pre><code>- (UIPresentationController *)presentationControllerForPresentedViewController:(UIViewController *)presented presentingViewController:(UIViewController *)presenting sourceViewController:(UIViewController *)source {
    // 关于 UIPresentationController 类的功能描述可以参照上面贴出的唐巧的博客，主要作用可以总结为自定义 presentedView 的尺寸以及添加动画。例如需要 Present 出来的 VC 并非满屏大小时（参照系统的 ActionSheet 控件），只需要在这里面做简单的设置即可；
}

- (id &lt;UIViewControllerAnimatedTransitioning&gt;)animationControllerForPresentedController:(UIViewController *)presented presentingController:(UIViewController *)presenting sourceController:(UIViewController *)source {
        // Present 动画执行时需要提供的动画控制器
}

- (id &lt;UIViewControllerAnimatedTransitioning&gt;)animationControllerForDismissedController:(UIViewController *)dismissed {
    // Dismiss 动画执行时需要提供的动画控制器
        // ps: 方便的做法是共用一个动画控制器，通过 Bool 值区别是 Present 或者 Dismiss，来区别动画实现细节
}

- (id&lt;UIViewControllerInteractiveTransitioning&gt;)interactionControllerForDismissal:(id&lt;UIViewControllerAnimatedTransitioning&gt;)animator {
    // 为转场增加手势控制
}


</code></pre>

<h4>2.转场的动画控制器</h4>

无论是上面哪种控制器的转场代理，均需要提供一个实现了 <code>&lt;UIViewControllerAnimatedTransitioning&gt;</code> 协议的动画控制器，一般新建一个继承自<code>NSObject</code>的类遵循并实现这个协议即可。<br />
该协议主要实现两个方法：

<pre><code>// 转场动画的时间
-(NSTimeInterval)transitionDuration:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext;
// 转场动画的具体实现
-(void)animateTransition:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext;
</code></pre>

核心点在于 <code>-(void)animateTransition:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext;</code> 方法的实现。

<h4>3.转场动画实现的相关细节</h4>

上下文参数 <code>transitionContext</code> 遵循了 <code>&lt;UIViewControllerContextTransitioning&gt;</code> 协议，开发者们可以根据上下文拿到实现动画所需要的重要的信息：

<pre><code>// 动画发生的容器 View
transitionContext.containerView;

// 转场前后两个 ViewController
[transitionContext viewControllerForKey:UITransitionContextFromViewControllerKey];
[transitionContext viewControllerForKey:UITransitionContextToViewControllerKey];

// 转场前后两个 View （即为 ViewController.view）
[transitionContext viewForKey:UITransitionContextFromViewKey];
[transitionContext viewForKey:UITransitionContextToViewKey];

// 控制器在转场前后的 frame
[transitionContext initialFrameForViewController:(UIViewController *)vc];
[transitionContext finalFrameForViewController:(UIViewController *)vc];

// 动画执行结束一定要调用这个方法
-(void)completeTransition:(BOOL)didComplete;
</code></pre>

总的来说就是系统提供给了开发者一个 <code>containerView</code>，以及将要进行动画的前后两个视图控制器的 <code>View</code>，由开发者来自行实现动画，并在动画结束时调用 <code>-(void)completeTransition:(BOOL)didComplete</code> 方法告知动画结束。因此对于开发者来说，问题简化为了容器 View 上的两个子 View 如何展现动画的简单问题。

这里有几点细节需要注意：
1. Present / Push 动画需要手动将 <code>UITransitionContextToViewKey</code> 对应的 <code>View</code> addSubview 到 <code>containerView</code> 中。
2. 动画的实现可以采用 CALayer 动画或者 UIView 动画，但是实测在 iOS 11 下，CALayer 动画无法通过手势控制器实时控制动画进度，不清楚是不是 bug。
3. 动画结束请一定要调用 <code>-(void)completeTransition:(BOOL)didComplete</code>。

这里贴一个简单的栗子

<pre><code>- (NSTimeInterval)transitionDuration:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext {
    return 0.4; // 动画执行时间
}

- (void)animateTransition:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext {
    // isPresentation 属性为初始化时传入，区别是 Present 还是 Dismiss
    NSString *key = self.isPresentation ? UITransitionContextToViewControllerKey : UITransitionContextFromViewControllerKey;
    UIViewController *controller = [transitionContext viewControllerForKey:key];

    if (self.isPresentation) {
        [transitionContext.containerView addSubview:controller.view];
    }

    CGRect presentedFrame = [transitionContext finalFrameForViewController:controller];
        CGRect dismissedFrame.origin.y = transitionContext.containerView.bounds.size.height;


    CGRect initialFrame = self.isPresentation ? dismissedFrame : presentedFrame;
    CGRect finalFrame = self.isPresentation ? presentedFrame : dismissedFrame;

    NSTimeInterval duration = [self transitionDuration:transitionContext];
    controller.view.frame = initialFrame;

    [UIView animateWithDuration:duration delay:0.f usingSpringWithDamping:1.f initialSpringVelocity:5.f options:UIViewAnimationOptionCurveEaseInOut animations:^{
        controller.view.frame = finalFrame;
    } completion:^(BOOL finished) {
        [transitionContext completeTransition:finished];
    }];

}

</code></pre>

<h4>4.手势驱动改变动画进度</h4>

系统提供了一个实现 <code>UIViewControllerInteractiveTransitioning</code> 协议的<code>UIPercentDrivenInteractiveTransition</code>类，所以我们只要继承这个类，添加手势并在手势实现的方法中告知当前视图的百分比，通过此逻辑来驱动视图，在调用类中定义的一些方法就很容易实现视图的交互。

核心方法有三个：

<pre><code>// 更新动画百分比
-(void)updateInteractiveTransition:(CGFloat)percentComplete;
// 取消视图交互，返回动画执行前的状态
-(void)cancelInteractiveTransition;
// 继续完成动画，更新到完成后的状态
-(void)finishInteractiveTransition;
</code></pre>

实现方式通常如下：

<pre><code>@interface MERPresentationInteractive ()
@property (nonatomic, weak) UIViewController *dismissedVC;
@property (nonatomic, strong) UIScreenEdgePanGestureRecognizer *panGesture;
@end

@implementation MERPresentationInteractive

- (instancetype)init {
    self = [super init];
    if (self) {
        _isInteracting = NO;
    }
    return self;
}

- (void)setDismissGestureRecognizerToViewController:(UIViewController *)viewController {
        // 为被 Present 出来的 VC 添加滑动手势
    _dismissedVC = viewController;
    UIViewController *vc = viewController;
    if ([viewController isKindOfClass:[UINavigationController class]]) {
        UINavigationController *navi = (UINavigationController *)viewController;
        vc = navi.topViewController;
    }
    if (!_panGesture) {
        _panGesture = [[UIScreenEdgePanGestureRecognizer alloc] initWithTarget:self action:@selector(handlePan:)];
        _panGesture.edges = UIRectEdgeLeft;
    }
    if (![[vc.view gestureRecognizers] containsObject:_panGesture]) {
        [vc.view addGestureRecognizer:_panGesture];
    }
}

- (void)handlePan:(UIScreenEdgePanGestureRecognizer*)recognizer {

    if (recognizer.state == UIGestureRecognizerStateBegan) {
        _isInteracting = YES;
        [_dismissedVC dismissViewControllerAnimated:YES completion:nil]; // 开始执行动画
    }
    else if (recognizer.state == UIGestureRecognizerStateChanged) {
        if (!_isInteracting) {
            return;
        }
        CGFloat progress = [recognizer translationInView:[UIApplication sharedApplication].keyWindow].x / ([UIApplication sharedApplication].keyWindow.bounds.size.width * 1.0);
        progress = MIN(1.0, MAX(0.0, progress));

        [self updateInteractiveTransition:progress]; // 根据手势实时更新动画进度
    }
    else if (recognizer.state == UIGestureRecognizerStateEnded || recognizer.state == UIGestureRecognizerStateCancelled) {
        if (!_isInteracting) {
            return;
        }

        CGFloat progress = [recognizer translationInView:[UIApplication sharedApplication].keyWindow].x / (_dismissedVC.view.bounds.size.width * 1.0);
        progress = MIN(1.0, MAX(0.0, progress));

        if (@available(iOS 11.0,*)) {
                // 此处由于在实现点扩散转场动画中，iOS 11下执行取消仍然会完成动画，因此对iOS 11区别处理了
            self.completionSpeed = 1 - progress;
            [self finishInteractiveTransition];
        } else {
            CGPoint velocity = [recognizer velocityInView:[UIApplication sharedApplication].keyWindow];
                        // 根据进度和速度方向来确定完成和取消的阈值，因人而异，可随意调整
            if ((progress &gt; 0.25 &amp;&amp; velocity.x &gt; 0) || progress &gt; 0.5) {
                NSLog(@"Pop完成");
                self.completionSpeed = 1;
                [self finishInteractiveTransition];
            } else {
                NSLog(@"Pop取消");
                [self updateInteractiveTransition:0.f];
                [self cancelInteractiveTransition];
            }
        }
        _isInteracting = NO;
    }
}
@end

</code></pre>

<h4>5.在分类中使用</h4>

新建 <code>UIViewController</code> 的分类，新增自定义的 Present 方法，在实现中为被 Present 的 <code>ViewController</code> 添加转场代理，并设置 <code>UIModalPresentationStyle</code> 为 <code>UIModalPresentationCustom</code>。

例如这样：

<pre><code>- (void)presentFadePatternViewController:(UIViewController *)viewControllerToPresent
                                animated:(BOOL)flag
                              completion:(void (^)(void))completion {

    MERGraduallyFadePresentationManager *graduallyFadePresentationManager = [[MERGraduallyFadePresentationManager alloc] init];

    viewControllerToPresent.modalPresentationStyle = UIModalPresentationCustom;
    viewControllerToPresent.transitioningDelegate = graduallyFadePresentationManager;

    [self presentViewController:viewControllerToPresent animated:flag completion:completion];
}
</code></pre>

后续的拓展，只需要根据需求，新增动画代理控制器、转场代理控制器，然后像这样修改 <code>ViewController</code> 的 <code>transitioningDelegate</code> 即可。

<h2>目前发现的坑</h2>

问题主要集中在 iOS 11 及 iOS 11系统以下，动画的展示细节可能会有不同，也不清楚苹果又重构了他们什么代码实现……因此做转场请一定要在不同的系统环境下都跑一次看看。

<a href="https://github.com/Mervin1024/MERPresentation">Github地址</a>

<h2>文章参考</h2>

<a href="https://onevcat.com/2013/10/vc-transition-in-ios7/">ViewController切换</a>
<a href="http://blog.devtang.com/2016/03/13/iOS-transition-guide/">iOS 视图控制器转场详解</a>
<a href="https://www.jianshu.com/p/9e62afe9d995">iOS开发 - 自定义转场</a>]]></content:encoded>
		<excerpt:encoded><![CDATA[代码拓展性和移植性较高，更多的在工作中使用到的跳转动画也会在这里更新]]></excerpt:encoded>
		<wp:post_id>172</wp:post_id>
		<wp:post_date><![CDATA[2018-04-20 22:47:06]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-04-20 14:47:06]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e4%b8%80%e8%a1%8c%e4%bb%a3%e7%a0%81%e5%ae%8c%e6%88%90%e9%a1%b5%e9%9d%a2%e8%87%aa%e5%ae%9a%e4%b9%89%e8%b7%b3%e8%bd%ac]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="ios"><![CDATA[iOS]]></category>
		<category domain="category" nicename="ios-development-diary"><![CDATA[iOS技术]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_thumbnail_id]]></wp:meta_key>
			<wp:meta_value><![CDATA[173]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[32]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_rp_related_posts_query_result_cache_expiration]]></wp:meta_key>
			<wp:meta_value><![CDATA[1532162726]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_rp_related_posts_query_result_cache_5]]></wp:meta_key>
			<wp:meta_value><![CDATA[a:7:{i:0;O:8:"stdClass":2:{s:7:"post_id";s:3:"182";s:5:"score";s:18:"13.000528096888573";}i:1;O:8:"stdClass":2:{s:7:"post_id";s:3:"120";s:5:"score";s:18:"12.189597880672244";}i:2;O:8:"stdClass":2:{s:7:"post_id";s:2:"60";s:5:"score";s:18:"10.803303519552353";}i:3;O:8:"stdClass":2:{s:7:"post_id";s:2:"63";s:5:"score";s:17:"9.992373303336024";}i:4;O:8:"stdClass":2:{s:7:"post_id";s:3:"147";s:5:"score";s:18:"0.8109302162163288";}i:5;O:8:"stdClass":2:{s:7:"post_id";s:3:"116";s:5:"score";s:18:"0.8109302162163288";}i:6;O:8:"stdClass":2:{s:7:"post_id";s:2:"68";s:5:"score";s:18:"0.8109302162163288";}}]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>iOS 全局修改系统导航栏返回按钮样式</title>
		<link>https://mervin1024.com/technical-blogs/ios-development-diary/post-182</link>
		<pubDate>Wed, 09 May 2018 09:18:54 +0000</pubDate>
		<dc:creator><![CDATA[mervin1024]]></dc:creator>
		<guid isPermaLink="false">https://mervin1024.com/?p=182</guid>
		<description></description>
		<content:encoded><![CDATA[<h2>前言</h2>

我之前有写过一个关于全局设置导航栏返回按钮的文章，<a href="https://mervin1024.com/technical-blogs/ios-development-diary/post-120">在这里</a>。通过类别的方式，直接导入文件即可生效。但是有几点不便之处：一是没有暴露接口去设置返回按钮的样式，默认样式直接写在类的方法实现中；二是没有使用 cocoapods 管理，不符合工具类组件化管理的原则。因此做了二次修改。

<h2>使用</h2>

直接使用 pod 导入

pod 'MERNavigationBackItem'

默认返回按钮文字为 “返回”，也可以通过 appearance 修改全局返回按钮文字或样式

<pre><code>#import &lt;MERNavigationBackItem/MERNavigationBackItem.h&gt;

@implementation MERAppDelegate

- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
{
    [UINavigationBar appearance].mer_globalBackBarButtonTitle = @"测试";
    //或者返回自定义 UIBarButtonItem
    //[UINavigationBar appearance].mer_globalBackBarButtonItem = [[UIBarButtonItem alloc] initWithImage:[UIImage imageNamed:@"backImage"] style:UIBarButtonItemStylePlain target:nil action:NULL];



    // Override point for customization after application launch.
    return YES;
}
</code></pre>

设置文字为 " " 空格字符串即可隐藏返回按钮文字，只保留返回箭头（自己的项目中是这样使用的）。<br />
因为设置的是默认样式，如果为单一页面定制返回按钮则默认样式不会生效。<br />
适用 iOS 11 及以下系统。

<h2>结束</h2>

因为是二次修改，实现思路可以参照前一篇文章，这里就不多赘述了。<br />
<a href="https://github.com/Mervin1024/MERNavigationBackItem">github 在这里</a>。]]></content:encoded>
		<excerpt:encoded><![CDATA[修改版，增加了 cocoapods 支持，提供了属性以便自定义按钮样式。]]></excerpt:encoded>
		<wp:post_id>182</wp:post_id>
		<wp:post_date><![CDATA[2018-05-09 17:18:54]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-05-09 09:18:54]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[ios-%e5%85%a8%e5%b1%80%e4%bf%ae%e6%94%b9%e7%b3%bb%e7%bb%9f%e5%af%bc%e8%88%aa%e6%a0%8f%e8%bf%94%e5%9b%9e%e6%8c%89%e9%92%ae%e6%a0%b7%e5%bc%8f]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="ios"><![CDATA[iOS]]></category>
		<category domain="category" nicename="ios-development-diary"><![CDATA[iOS技术]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[22]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_thumbnail_id]]></wp:meta_key>
			<wp:meta_value><![CDATA[121]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_rp_related_posts_query_result_cache_expiration]]></wp:meta_key>
			<wp:meta_value><![CDATA[1531800527]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_rp_related_posts_query_result_cache_5]]></wp:meta_key>
			<wp:meta_value><![CDATA[a:7:{i:0;O:8:"stdClass":2:{s:7:"post_id";s:3:"120";s:5:"score";s:18:"14.685967430464192";}i:1;O:8:"stdClass":2:{s:7:"post_id";s:3:"172";s:5:"score";s:17:"10.52708434710452";}i:2;O:8:"stdClass":2:{s:7:"post_id";s:2:"63";s:5:"score";s:17:"9.951720202700958";}i:3;O:8:"stdClass":2:{s:7:"post_id";s:2:"60";s:5:"score";s:17:"8.565425841581067";}i:4;O:8:"stdClass":2:{s:7:"post_id";s:3:"116";s:5:"score";s:18:"5.3096113721667955";}i:5;O:8:"stdClass":2:{s:7:"post_id";s:3:"147";s:5:"score";s:17:"2.537022649927014";}i:6;O:8:"stdClass":2:{s:7:"post_id";s:2:"68";s:5:"score";s:18:"0.5753641444035617";}}]]></wp:meta_value>
		</wp:postmeta>
	</item>
</channel>
</rss>
